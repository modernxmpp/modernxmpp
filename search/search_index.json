{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Modern XMPP \u00b6 Overview \u00b6 Modern XMPP is an independent project launched to improve the quality of user-to-user messaging applications that use XMPP. XMPP is a mature open standard for internet messaging. If you're reading this, you've probably heard of it. We're developing a handful of simple documents aimed at people who wish to build on top of XMPP. The recommendations are derived from healthy discussions between developers from multiple XMPP projects and other members of the XMPP community. Our recommendations highlight only the XEPs you need to implement for a modern messaging application, ignoring historical cruft and excessive backwards-compatibility. We also intend to provide a comprehensive set of guidelines for UI design. Developing a client was never just about the protocol. In fact in most cases the protocol is a secondary concern. Having a concrete set of guidelines will help to provide a more uniform user experience between different applications, ensuring they use the same terminology, and provide interoperable feature sets. Times change, and we expect our recommendations to evolve over time. Our guidelines will be versioned, and thus make it possible to identify and weed out software that falls behind the times. Current status \u00b6 It's early days. We are still building the foundations of what will become the initial set of documents. Nevertheless, we already have a bunch of stuff documented that developers of XMPP software (both new and experienced) will find useful. This includes design guidelines and lower-level protocol implementation recommendations . If you're interested in joining us, our primary discussion venue is our channel which can be reached at: XMPP: modernxmpp@rooms.modernxmpp.org Web: chat.modernxmpp.org Contributions to the docs can be made through Github modernxmpp/modernxmpp .","title":"Home"},{"location":"#modern-xmpp","text":"","title":"Modern XMPP"},{"location":"#overview","text":"Modern XMPP is an independent project launched to improve the quality of user-to-user messaging applications that use XMPP. XMPP is a mature open standard for internet messaging. If you're reading this, you've probably heard of it. We're developing a handful of simple documents aimed at people who wish to build on top of XMPP. The recommendations are derived from healthy discussions between developers from multiple XMPP projects and other members of the XMPP community. Our recommendations highlight only the XEPs you need to implement for a modern messaging application, ignoring historical cruft and excessive backwards-compatibility. We also intend to provide a comprehensive set of guidelines for UI design. Developing a client was never just about the protocol. In fact in most cases the protocol is a secondary concern. Having a concrete set of guidelines will help to provide a more uniform user experience between different applications, ensuring they use the same terminology, and provide interoperable feature sets. Times change, and we expect our recommendations to evolve over time. Our guidelines will be versioned, and thus make it possible to identify and weed out software that falls behind the times.","title":"Overview"},{"location":"#current-status","text":"It's early days. We are still building the foundations of what will become the initial set of documents. Nevertheless, we already have a bunch of stuff documented that developers of XMPP software (both new and experienced) will find useful. This includes design guidelines and lower-level protocol implementation recommendations . If you're interested in joining us, our primary discussion venue is our channel which can be reached at: XMPP: modernxmpp@rooms.modernxmpp.org Web: chat.modernxmpp.org Contributions to the docs can be made through Github modernxmpp/modernxmpp .","title":"Current status"},{"location":"rationale/","text":"Rationale \u00b6 This page gives additional insight into why some of the recommendations in the Modern XMPP documentation are made. Group chats \u00b6 Discussion about the UI/UX issues around group chats initially happened at the first UX sprint . Some observations were made: MUC configuration is messy, for users and developers Most MUCs fall roughly into a couple of standard configurations Types of groups \u00b6 Software is about people. Good UX design is about understanding how people use the software. Group communication is a well-studied area of human interaction in general 1 . It has been noted by researchers that groups can fall into four different types 2 . Of the four group types, two are formed of people that share a personal or social connection (the so-called 'Primary' and 'Social' groups). Examples include families, groups of friends, colleagues or clubs. The other two group types ('Collective' and 'Category') are formed from people who share common traits, goals or interests. Such groups tend to be larger, less sticky, lack concrete social bonds and thus be more open. The developers of the Fractal IM client noted 3 the struggle they faced trying to design an ideal UI for chats in their Matrix client. They observed the two high-level categories which they termed \"Barbeque\" (small, social-focused, closed, trusted) and \"Banquet\" (large, topic-focused, open, untrusted). The Fractal developers went as far to consider two completely separate applications to cater for the two types of discussions. Many other modern messaging apps contain both types of group chat, but unlike most XMPP clients, they do distinguish them visually. From a protocol perspective this distinction is unnatural - XMPP, like similar open chat protocols such as IRC and Matrix cares little for how the group is used, and provides various fine-grained configuration options. Other than minor configuration tweaks there is little to distinguish the two use-cases at a technical level. However dividing these up at the UI level provides a number of advantages: Removes/reduces the need for fine-grained configuration options that users may not understand, or mis-use Helps prevent user confusion when sharing content (it is harder to accidentally share family photos with an open-source project's chatroom full of strangers, if the family group and project group are strongly separated) Makes managing notification rules easier Terminology \u00b6 It was agreed that \"room\" terminology is outdated 4 , and not used by any modern messaging systems. s a result, people do not tend to be familiar https://en.wikipedia.org/wiki/Group_dynamics \u21a9 https://en.wikipedia.org/wiki/Group_dynamics#Types_of_groups \u21a9 https://blogs.gnome.org/tbernard/2018/05/16/banquets-and-barbecues/ \u21a9 Google Trends notes a significant decline since at least 2004 . \u21a9","title":"Rationale"},{"location":"rationale/#rationale","text":"This page gives additional insight into why some of the recommendations in the Modern XMPP documentation are made.","title":"Rationale"},{"location":"rationale/#group-chats","text":"Discussion about the UI/UX issues around group chats initially happened at the first UX sprint . Some observations were made: MUC configuration is messy, for users and developers Most MUCs fall roughly into a couple of standard configurations","title":"Group chats"},{"location":"rationale/#types-of-groups","text":"Software is about people. Good UX design is about understanding how people use the software. Group communication is a well-studied area of human interaction in general 1 . It has been noted by researchers that groups can fall into four different types 2 . Of the four group types, two are formed of people that share a personal or social connection (the so-called 'Primary' and 'Social' groups). Examples include families, groups of friends, colleagues or clubs. The other two group types ('Collective' and 'Category') are formed from people who share common traits, goals or interests. Such groups tend to be larger, less sticky, lack concrete social bonds and thus be more open. The developers of the Fractal IM client noted 3 the struggle they faced trying to design an ideal UI for chats in their Matrix client. They observed the two high-level categories which they termed \"Barbeque\" (small, social-focused, closed, trusted) and \"Banquet\" (large, topic-focused, open, untrusted). The Fractal developers went as far to consider two completely separate applications to cater for the two types of discussions. Many other modern messaging apps contain both types of group chat, but unlike most XMPP clients, they do distinguish them visually. From a protocol perspective this distinction is unnatural - XMPP, like similar open chat protocols such as IRC and Matrix cares little for how the group is used, and provides various fine-grained configuration options. Other than minor configuration tweaks there is little to distinguish the two use-cases at a technical level. However dividing these up at the UI level provides a number of advantages: Removes/reduces the need for fine-grained configuration options that users may not understand, or mis-use Helps prevent user confusion when sharing content (it is harder to accidentally share family photos with an open-source project's chatroom full of strangers, if the family group and project group are strongly separated) Makes managing notification rules easier","title":"Types of groups"},{"location":"rationale/#terminology","text":"It was agreed that \"room\" terminology is outdated 4 , and not used by any modern messaging systems. s a result, people do not tend to be familiar https://en.wikipedia.org/wiki/Group_dynamics \u21a9 https://en.wikipedia.org/wiki/Group_dynamics#Types_of_groups \u21a9 https://blogs.gnome.org/tbernard/2018/05/16/banquets-and-barbecues/ \u21a9 Google Trends notes a significant decline since at least 2004 . \u21a9","title":"Terminology"},{"location":"terminology/","text":"Terminology \u00b6 To reduce user confusion when switching between clients, it is good to use only recommended terms. Historic terms Recommended terms MUC, Room, Chatroom, Conference Group chat or Channel (see Multi-user Chats ) Occupant Participant JID Address or XMPP address Roster Contact list","title":"Terminology"},{"location":"terminology/#terminology","text":"To reduce user confusion when switching between clients, it is good to use only recommended terms. Historic terms Recommended terms MUC, Room, Chatroom, Conference Group chat or Channel (see Multi-user Chats ) Occupant Participant JID Address or XMPP address Roster Contact list","title":"Terminology"},{"location":"client/design/","text":"Client design guidelines \u00b6 This document lays out a set of guidelines for designing Modern XMPP clients. For contributions, please open an issue or pull request at Github for discussion. Registration \u00b6 Todo Initial configuration \u00b6 At initial startup, a client should present a welcome screen, to prompt the user for their JID, and a password. Optionally, a button or link to provide other forms of credentials may be included. If the client has an out-of-band configuration mechanism, or it can query the OS for sensible defaults, it may use these. Configuration options \u00b6 List recommended configuration options. Account \u00b6 Option Description JID The user's JID Password The user's password Network \u00b6 Support for these options is OPTIONAL. If included in the client, they MUST NOT be requested by default at startup, but should be accessible through an advanced options interface. Option Description Connect host The network hostname to connect to Connect port The network port to connect to TLS Mode 2 Multiple choice: \"STARTTLS\" or \"Direct TLS\" Both of the above should be automatically discovered from DNS, according to the rules in RFC 6120 . Clients that support other connection mechanisms, such as BOSH, SHOULD also implement XEP-0156 . Deprecated options \u00b6 Support for these options is NOT RECOMMENDED. Option Description Notes Resource The resource to request from the server see Resource generation Priority The priority to include in presence 0 User status \u00b6 The client, by default, MUST NOT include any status messages in its presence, unless they are chosen by the user. Built-in status messages that convey the same meaning as the user's selected 'show' value (e.g. \"Available\", \"Do not disturb\") are not allowed. Allowing the user to set a status message is an OPTIONAL feature. Contact list \u00b6 Terminology \u00b6 In its interface, the client MUST NOT use the technical term \"roster\", but MUST instead use the term \"contact list\" (or a suitable translation) where necessary. See the main \"Terminology\" section for more information. Offline contacts \u00b6 The client MUST display offline contacts by default, and allow sending messages to them, as for online contacts.. Sorting of contact list \u00b6 The client MUST sort the contact list. Either in lexicographical order by contact name or chronologically by the time of the last message exchanged with that contact. Visualizing status \u00b6 The client MUST display status messages of contacts when present. It MAY also provide visual indication of the contact's status ('show'), but SHOULD NOT rely on color alone to distinguish different status values 1 . Todo Describe how to display multiple remote resources. Conversation view \u00b6 Message states \u00b6 Outgoing messages \u00b6 A client must be able to unambiguously display the following outgoing message states: Message pending delivery Message delivered to server Message delivered to contact Message read by contact Delivery error for message Todo Add table or flowchart Notifications \u00b6 Carbons, notifications for new messages in MAM Error handling \u00b6 Obey error types (modify, cancel, wait, etc.) Do display error text Multiple accounts \u00b6 Support for multiple accounts is OPTIONAL. Todo Research recommendations for the best way to handle multiple accounts. E.g. merge contacts, or not. Not required. Describe how to display multiple accounts in a single client? Group chat \u00b6 You can find more details about group chats here . Documentation \u00b6 Clients should have documentation covering essential functionality, including: Todo List of recommended documentation topics, e.g. how to add a contact Privacy \u00b6 Clients must not reveal full JID. Don't query unsubscribed contacts. Todo Probably belongs in protocol reference. Probably some things relevant to UI that should be mentioned, however. Names \u00b6 When displaying messages received from a remote JID, either within a one-to-one or multi-user chat, clients need to show a human-readable name for that sender. There are multiple sources for such a display name, which depend on the context (e.g. whether the conversation is one-to-one or a group chat). Name sources \u00b6 Valid sources are: Roster If the contact is in the user's roster, and the user has set a custom name. Address book Platform-dependent. If the application is somehow linked to the user's address book and is able to access a contact's information there. User nickname A nickname published by the sender in PEP per XEP-0172. Resource The resource of the sending JID. Local part The part of a bare JID before the '@' symbol. Bare JID The sending JID with any resource removed. Contexts \u00b6 The kind of view where a name is displayed decides which sources should be used. Since most sources are optional, they should be checked in the order described by the table below, displaying the first one available. View type Name priorities Conversation - normal Roster name, (Address book), User nickname, Local part Conversation - group Roster name, (Address book), User nickname, Resource (*) Conversation - channel Resource Contact list Roster name, User nickname, Bare JID User profile Roster name, User nickname, Bare JID (*) Mentions refer to resource. if you do proper references you can live replace it with the 'nice' name. Avatar display should follow the same order Resources for the use of color in interface design: WCAG 2.1: Understanding Use of Color Color contrast checker \u21a9 This is presented as a multiple-choice option. A checkbox labelled e.g. \"Direct TLS\" may confuse users by implying that the opposite of \"Direct TLS\" is potentially \"No TLS\". Security is not an option, and TLS is always used. This option is about what style the server supports. \u21a9","title":"User Interface"},{"location":"client/design/#client-design-guidelines","text":"This document lays out a set of guidelines for designing Modern XMPP clients. For contributions, please open an issue or pull request at Github for discussion.","title":"Client design guidelines"},{"location":"client/design/#registration","text":"Todo","title":"Registration"},{"location":"client/design/#initial-configuration","text":"At initial startup, a client should present a welcome screen, to prompt the user for their JID, and a password. Optionally, a button or link to provide other forms of credentials may be included. If the client has an out-of-band configuration mechanism, or it can query the OS for sensible defaults, it may use these.","title":"Initial configuration"},{"location":"client/design/#configuration-options","text":"List recommended configuration options.","title":"Configuration options"},{"location":"client/design/#account","text":"Option Description JID The user's JID Password The user's password","title":"Account"},{"location":"client/design/#network","text":"Support for these options is OPTIONAL. If included in the client, they MUST NOT be requested by default at startup, but should be accessible through an advanced options interface. Option Description Connect host The network hostname to connect to Connect port The network port to connect to TLS Mode 2 Multiple choice: \"STARTTLS\" or \"Direct TLS\" Both of the above should be automatically discovered from DNS, according to the rules in RFC 6120 . Clients that support other connection mechanisms, such as BOSH, SHOULD also implement XEP-0156 .","title":"Network"},{"location":"client/design/#deprecated-options","text":"Support for these options is NOT RECOMMENDED. Option Description Notes Resource The resource to request from the server see Resource generation Priority The priority to include in presence 0","title":"Deprecated options"},{"location":"client/design/#user-status","text":"The client, by default, MUST NOT include any status messages in its presence, unless they are chosen by the user. Built-in status messages that convey the same meaning as the user's selected 'show' value (e.g. \"Available\", \"Do not disturb\") are not allowed. Allowing the user to set a status message is an OPTIONAL feature.","title":"User status"},{"location":"client/design/#contact-list","text":"","title":"Contact list"},{"location":"client/design/#terminology","text":"In its interface, the client MUST NOT use the technical term \"roster\", but MUST instead use the term \"contact list\" (or a suitable translation) where necessary. See the main \"Terminology\" section for more information.","title":"Terminology"},{"location":"client/design/#offline-contacts","text":"The client MUST display offline contacts by default, and allow sending messages to them, as for online contacts..","title":"Offline contacts"},{"location":"client/design/#sorting-of-contact-list","text":"The client MUST sort the contact list. Either in lexicographical order by contact name or chronologically by the time of the last message exchanged with that contact.","title":"Sorting of contact list"},{"location":"client/design/#visualizing-status","text":"The client MUST display status messages of contacts when present. It MAY also provide visual indication of the contact's status ('show'), but SHOULD NOT rely on color alone to distinguish different status values 1 . Todo Describe how to display multiple remote resources.","title":"Visualizing status"},{"location":"client/design/#conversation-view","text":"","title":"Conversation view"},{"location":"client/design/#message-states","text":"","title":"Message states"},{"location":"client/design/#outgoing-messages","text":"A client must be able to unambiguously display the following outgoing message states: Message pending delivery Message delivered to server Message delivered to contact Message read by contact Delivery error for message Todo Add table or flowchart","title":"Outgoing messages"},{"location":"client/design/#notifications","text":"Carbons, notifications for new messages in MAM","title":"Notifications"},{"location":"client/design/#error-handling","text":"Obey error types (modify, cancel, wait, etc.) Do display error text","title":"Error handling"},{"location":"client/design/#multiple-accounts","text":"Support for multiple accounts is OPTIONAL. Todo Research recommendations for the best way to handle multiple accounts. E.g. merge contacts, or not. Not required. Describe how to display multiple accounts in a single client?","title":"Multiple accounts"},{"location":"client/design/#group-chat","text":"You can find more details about group chats here .","title":"Group chat"},{"location":"client/design/#documentation","text":"Clients should have documentation covering essential functionality, including: Todo List of recommended documentation topics, e.g. how to add a contact","title":"Documentation"},{"location":"client/design/#privacy","text":"Clients must not reveal full JID. Don't query unsubscribed contacts. Todo Probably belongs in protocol reference. Probably some things relevant to UI that should be mentioned, however.","title":"Privacy"},{"location":"client/design/#names","text":"When displaying messages received from a remote JID, either within a one-to-one or multi-user chat, clients need to show a human-readable name for that sender. There are multiple sources for such a display name, which depend on the context (e.g. whether the conversation is one-to-one or a group chat).","title":"Names"},{"location":"client/design/#name-sources","text":"Valid sources are: Roster If the contact is in the user's roster, and the user has set a custom name. Address book Platform-dependent. If the application is somehow linked to the user's address book and is able to access a contact's information there. User nickname A nickname published by the sender in PEP per XEP-0172. Resource The resource of the sending JID. Local part The part of a bare JID before the '@' symbol. Bare JID The sending JID with any resource removed.","title":"Name sources"},{"location":"client/design/#contexts","text":"The kind of view where a name is displayed decides which sources should be used. Since most sources are optional, they should be checked in the order described by the table below, displaying the first one available. View type Name priorities Conversation - normal Roster name, (Address book), User nickname, Local part Conversation - group Roster name, (Address book), User nickname, Resource (*) Conversation - channel Resource Contact list Roster name, User nickname, Bare JID User profile Roster name, User nickname, Bare JID (*) Mentions refer to resource. if you do proper references you can live replace it with the 'nice' name. Avatar display should follow the same order Resources for the use of color in interface design: WCAG 2.1: Understanding Use of Color Color contrast checker \u21a9 This is presented as a multiple-choice option. A checkbox labelled e.g. \"Direct TLS\" may confuse users by implying that the opposite of \"Direct TLS\" is potentially \"No TLS\". Security is not an option, and TLS is always used. This option is about what style the server supports. \u21a9","title":"Contexts"},{"location":"client/groupchat/","text":"Multi-user Chats \u00b6 Types of chat \u00b6 There are two kinds of multi-user chat. Private group chats , and public channels . Properties \u00b6 Group chat Channel Persistent Yes Yes MAM enabled Yes Yes Subject editable No No Members-only Yes (*) No JIDs revealed Yes (*) No Publicly listed No (*) Yes PMs No (*) Yes (*) Immutable for group chats . Terminology \u00b6 People in the group chat / channel : Participants Roles are not displayed and cannot be modified through the UI. Affiliations In group chats In channels none N/A ** Guest member - - admin Admin (*) Admin owner Owner Owner (*) A group chat will display an existing admin as such but it will not encourage/allow someone to be promoted to admin. UI options in group chats only allow a member to become an owner but not admin. So admins are discouraged by the UI but will be displayed as such if the end up being one for some reason. (**) Everybody is a member in group chats Clients MAY create an 'advanced view' that displays roles as well. User nickname \u00b6 When joining a group chat, a client needs to select a nickname to use. There are multiple sources from which this name may be selected. The client should use the following sources in order: Bookmark If the chat is present in the user's bookmarks and has a nickname present (as the resource). Reserved name A chat may be queried to fetch the name that is registered by the user for that chat. User nickname (PEP) The name stored in the user's account according to XEP-0172 . User nickname (vCard) The name stored in the user's vCard as NICKNAME . Local nickname (Optional, not recommended 1 ) A nickname previously configured by the user in this client instance. JID username The username portion of the user's JID (i.e. before the '@'). Bookmarks \u00b6 Todo Bookmark management logic To avoid requiring the user to configure a nickname manually on each device, shared cross-device stores such as PEP and vCard should be preferred. \u21a9","title":"Multi-user Chats"},{"location":"client/groupchat/#multi-user-chats","text":"","title":"Multi-user Chats"},{"location":"client/groupchat/#types-of-chat","text":"There are two kinds of multi-user chat. Private group chats , and public channels .","title":"Types of chat"},{"location":"client/groupchat/#properties","text":"Group chat Channel Persistent Yes Yes MAM enabled Yes Yes Subject editable No No Members-only Yes (*) No JIDs revealed Yes (*) No Publicly listed No (*) Yes PMs No (*) Yes (*) Immutable for group chats .","title":"Properties"},{"location":"client/groupchat/#terminology","text":"People in the group chat / channel : Participants Roles are not displayed and cannot be modified through the UI. Affiliations In group chats In channels none N/A ** Guest member - - admin Admin (*) Admin owner Owner Owner (*) A group chat will display an existing admin as such but it will not encourage/allow someone to be promoted to admin. UI options in group chats only allow a member to become an owner but not admin. So admins are discouraged by the UI but will be displayed as such if the end up being one for some reason. (**) Everybody is a member in group chats Clients MAY create an 'advanced view' that displays roles as well.","title":"Terminology"},{"location":"client/groupchat/#user-nickname","text":"When joining a group chat, a client needs to select a nickname to use. There are multiple sources from which this name may be selected. The client should use the following sources in order: Bookmark If the chat is present in the user's bookmarks and has a nickname present (as the resource). Reserved name A chat may be queried to fetch the name that is registered by the user for that chat. User nickname (PEP) The name stored in the user's account according to XEP-0172 . User nickname (vCard) The name stored in the user's vCard as NICKNAME . Local nickname (Optional, not recommended 1 ) A nickname previously configured by the user in this client instance. JID username The username portion of the user's JID (i.e. before the '@').","title":"User nickname"},{"location":"client/groupchat/#bookmarks","text":"Todo Bookmark management logic To avoid requiring the user to configure a nickname manually on each device, shared cross-device stores such as PEP and vCard should be preferred. \u21a9","title":"Bookmarks"},{"location":"client/protocol/","text":"XMPP Protocol Guidelines \u00b6 Overview \u00b6 The XSF has published nearly 400 XEPs over many years. However as technology, user expectations and best practices evolve, the protocol too is always evolving. This leads to confusion about which set of XEPs are \"current\", which are required only for backwards-compatibility, and which serve only to document experimental protocols that never made it off the drawing board. Instead of focusing on XEP numbers, this document simply focuses on the different areas of functionality, and describes the currently-recommended XEPs that should be used to implement each. Notes are provided to provide context about past and future versions of the protocol, which may be helpful for backwards-compatibility or planning future development. Target audience \u00b6 The protocols discussed here should be implemented in reusable libraries. Client developers may use this document to assist them in choosing an XMPP library, or submitting feature requests or contributions to their library of choice. Reusing libraries whenever possible reduces fragmentation and duplicated effort. Core \u00b6 Service discovery \u00b6 One of the unique features of XMPP is its ability to support a diverse range of software on a single network, yet always allow basic functionality to work. Either due to the ongoing evolution of technology, or due to constrained environments (e.g. IoT) or usage restrictions (e.g. accessibility), different XMPP software may support different sets of features on top of the core messaging and presence functionality described in the RFCs. It is often useful to know what features a remote entity supports before performing some operation. For example when deciding whether to send formatted messages, or determining the best available method of transferring a file. XEP-0030 is the basic mechanism for advertising and discovering features XEP-0115 is a strongly recommended extension that allows caching of these features Notes \u00b6 XEP-0115 may be revised or replaced at some point in the future, such as by XEP-0390, to allow hash agility and making the algorithm more robust to cache poisoning attacks. Resource generation \u00b6 The client should generate a unique random identifier per device or client instance. The identifier should be reused between sessions, and should not reveal any information about the user, their device, or their location. Messaging \u00b6 This section covers some protocols that are useful for general messaging. Formatting \u00b6 The current recommendation is that developers may simply implement the rules in XEP-0393 for formatting message bodies that they receive. XHTML-IM deprecation \u00b6 A previous formatting specification defined in XEP-0071 has been deprecated. Many implementations failed to properly sanitize the formatted payload (it's tricky), leading to security issues (particularly in web applications). Implementation of XEP-0071 is not encouraged, but if formatting is a strong requirement along with backwards compatibility (many clients still implement it currently), it remains an option if careful attention is given to sanitizing the XHTML before display. Consider using xhtml-im.js in a web client, or as a reference. Multi-device \u00b6 XMPP was ahead of its time in supporting multiple devices connected to a single account - although interestingly even today some popular messaging systems are still limited to a single device, typically mobile, even when many people have a mobile, tablet and laptop or desktop. Historically XMPP aimed to determine which device the user most likely wanted to receive messages on - it did this using a 'priority' mechanism in presence. Over time bandwidth and CPU costs, as well as user expectations, have shifted. Today most people want an \"everything everywhere\" approach to messaging, where all their devices are in sync. Modern XMPP clients should not set a priority in their presence, and they should implement the following XEPs: XEP-0280 - Carbons - for \"live\" synchronisation of conversations between online devices XEP-0313 - MAM - for \"catch-up\" of messages that were exchanged while a device was offline Known issues \u00b6 There are currently some minor open issues regarding these protocols that developers should be aware of. Race during login \u00b6 There is a race condition during login between Carbons and MAM. If you synchronize with the archive first, you may miss some messages sent to other devices before you enable Carbons. If you enable Carbons first, you may receive duplicates from the archive of messages you already received. The current best solution is to enable Carbons, perform the query, and de-duplicate any received messages before presentation to the user. This issue will be solved in the future through XEP-0386 or an alternative atomic \"fetch and subscribe\" command. IDs of outgoing messages \u00b6 When a client sends a message, it is not currently possible for it to discover the ID that the server assigned to the message in the archive. This means that it is unable to use them as synchronization points and therefore it may receive its last outgoing message(s) when performing an archive sync. Example: Client receives message A, and records the ID so it can use Client sends message B, but the ID is not known to the client Client goes offline Client comes online, and tries to sync with archive. Last known ID was of message A, so it synchronizes from that point Server responds to the sync with message B, and all subsequent messages. Solving this issue may happen through an extension of Carbons (to reflect sent messages back to the sender with the ID added and any other additional info), or through a new MAM subscription protocol. Mobile \u00b6 There are some special considerations that mobile clients can make to increase battery life and reduce data consumption. XEP-0286 - informational XEP providing advice to mobile developers on efficient data usage XEP-0352 - used to inform the server of whether the client is currently active/focused (which allows the server to prioritize traffic) Reliability \u00b6 In the real world, it is normal for clients to get briefly disconnected. These extensions deal with ensuring reliable message delivery and reporting. XEP-0184 - end-to-end acknowledgement, i.e. the recipient has successfully received the message XEP-0198 - hop-to-hop acknowledgement, and allows efficient resume of broken connections without data loss File transfer \u00b6 Transferring a file from A to B is surprisingly a non-trivial problem for the internet, it seems. A number of approaches have been tried in XMPP. They are documented here, and fall into two categories: peer-to-peer and server-mediated. It is strongly recommended for clients to implement HTTP upload to provide the best user experience. The other mechanisms are optional (the advantages of implementing each one are documented in the relevant section). There are three file transfer methods that a modern XMPP client may implement: HTTP upload (required) Jingle streams (recommended for large file support) Stream initiation (deprecated, but may be implemented for backwards-compatibility) HTTP upload \u00b6 Required: yes The newest file transfer mechanism available, described in XEP-0363. It is strongly recommended to implement this mechanism to provide the best user experience. Benefits \u00b6 Does not depend on the recipient supporting it (simply falls back to sending a URL) Works with group chats Works when the recipient is offline Allows the recipient to receive on multiple devices Disadvantages \u00b6 Unsuitable for large files (server determines what the size limit is, and may enforce usage quotas) Does not support streaming (file must be entirely uploaded to the server before recipient can begin to receive it) Requires server support Communicating the URL \u00b6 After uploading the file successfully, the sender should communicate the URL to the recipient by sending a <message> stanza with the \"Get URL\" provided by the server in the <body> of the message. Additionally the sender should include a jabber:x:oob element in the message stanza with the same URL. Note To enable automatic display of media in the conversation view, Conversations (at least) currently requires that the <body> contain just the URL, and it must be identical to the URL in the jabber:x:oob payload. The <desc> element is not used or supported by Conversations. This behaviour means that it is not possible for any text to directly accompany a media file, and must be sent separately. Jingle \u00b6 Required: optional - used for large file support Jingle is a generic framework that allows clients to negotiate a direct stream between themselves, which can be used to transfer files (it is also used for voice/video and other p2p applications based on XMPP). It was originally developed at Google and contributed to the XSF where it evolved into today's standard. Because it is a generic framework that supports different underlying transports and different media types, Jingle is split into multiple XEPs. For file transfer the following are relevant: XEP-0166 - the core Jingle framework XEP-0234 - the Jingle file transfer definition XEP-0260 - the most common transport mechanism for files (SOCKS5 bytestreams - may be directly peer-to-peer or server-mediated) XEP-0261 - a fallback transport for tunnelling the data directly over the XMPP stream (inefficient and slow, but always succeeds) Advantages \u00b6 Supports streaming (recipient receives at the same time as the sender sends) Allows code re-use if the client also implements Jingle for audio/video streams No server-side storage required, and the data will pass directly between clients if firewalls/network conditions allow, which makes it suitable for larger files. Disadvantages \u00b6 Because it is a multi-purpose framework it can be complex. Not all clients support it. In the case of the recipient having multiple devices, only a single one can receive the file. Does not work for sharing a file with multiple people (e.g. in a group chat) Only works if the recipient is online Note Although it is the only recommended negotiation protocol for peer-to-peer streams today, note that Jingle support is not nearly universal even among modern clients. Stream Initiation (pre-Jingle) \u00b6 Required: no - optionally implement for sending large files to pre-Jingle clients XEP-0096 describes the stream negotiation protocol that was used before Jingle. It is widely supported, and can use the same transports: XEP-0065 XEP-0047 It is not recommended to implement this mechanism in new clients, except for compatibility with older clients is required (and HTTP Upload does not suffice for some reason). Advantages \u00b6 Supports streaming (recipient receives at the same time as the sender sends) Widely supported in older clients Disadvantages \u00b6 Deprecated. Modern clients are switching to Jingle negotiation. In the case of the recipient having multiple devices, only a single one can receive the file. Does not work for sharing a file with multiple people (e.g. in a group chat) Only works if the recipient is online Avatars \u00b6 TODO Group chat \u00b6 TODO Contact management \u00b6 Blocking \u00b6 XEP-0191 for blocking communication with a list of other JIDs Encryption \u00b6 All XMPP streams must be encrypted using TLS as specified in RFC 6920. Clients may additionally support encrypting messages within the XMPP stream. This can prevent untrusted servers from viewing or modifying the contents of exchanged messsages, and is known as 'end-to-end encryption'. The current preferred protocol for this in XMPP is OMEMO, specified in XEP-0384. Client support is indicated at https://omemo.top/ . Notes \u00b6 OTR \u00b6 Prior to OMEMO, many clients implemented the protocol-agnostic encryption protocol \"OTR\". Although it sufficed for simple use cases (sender and recipient have a single device connected, and both support OTR), it has a number of drawbacks when used within XMPP. Traditionally it has not supported multiple devices very well, nor group chats, and it only protects the message body. These issues lead to a poor user experience. Modern XMPP clients that implement OTR must add a XEP-0380 tag to their outgoing messages. MLS \u00b6 The IETF is currently working on standardizing a new protocol for 'Message Layer Security' with support from a number of prominent members of the online communications space. It is hopeful that it may one day allow messaging applications of all protocols to share code and crypto reviewed by experts. However this work is in its early days, and OMEMO is expected to be the recommended approach for some time to come.","title":"Protocol"},{"location":"client/protocol/#xmpp-protocol-guidelines","text":"","title":"XMPP Protocol Guidelines"},{"location":"client/protocol/#overview","text":"The XSF has published nearly 400 XEPs over many years. However as technology, user expectations and best practices evolve, the protocol too is always evolving. This leads to confusion about which set of XEPs are \"current\", which are required only for backwards-compatibility, and which serve only to document experimental protocols that never made it off the drawing board. Instead of focusing on XEP numbers, this document simply focuses on the different areas of functionality, and describes the currently-recommended XEPs that should be used to implement each. Notes are provided to provide context about past and future versions of the protocol, which may be helpful for backwards-compatibility or planning future development.","title":"Overview"},{"location":"client/protocol/#target-audience","text":"The protocols discussed here should be implemented in reusable libraries. Client developers may use this document to assist them in choosing an XMPP library, or submitting feature requests or contributions to their library of choice. Reusing libraries whenever possible reduces fragmentation and duplicated effort.","title":"Target audience"},{"location":"client/protocol/#core","text":"","title":"Core"},{"location":"client/protocol/#service-discovery","text":"One of the unique features of XMPP is its ability to support a diverse range of software on a single network, yet always allow basic functionality to work. Either due to the ongoing evolution of technology, or due to constrained environments (e.g. IoT) or usage restrictions (e.g. accessibility), different XMPP software may support different sets of features on top of the core messaging and presence functionality described in the RFCs. It is often useful to know what features a remote entity supports before performing some operation. For example when deciding whether to send formatted messages, or determining the best available method of transferring a file. XEP-0030 is the basic mechanism for advertising and discovering features XEP-0115 is a strongly recommended extension that allows caching of these features","title":"Service discovery"},{"location":"client/protocol/#notes","text":"XEP-0115 may be revised or replaced at some point in the future, such as by XEP-0390, to allow hash agility and making the algorithm more robust to cache poisoning attacks.","title":"Notes"},{"location":"client/protocol/#resource-generation","text":"The client should generate a unique random identifier per device or client instance. The identifier should be reused between sessions, and should not reveal any information about the user, their device, or their location.","title":"Resource generation"},{"location":"client/protocol/#messaging","text":"This section covers some protocols that are useful for general messaging.","title":"Messaging"},{"location":"client/protocol/#formatting","text":"The current recommendation is that developers may simply implement the rules in XEP-0393 for formatting message bodies that they receive.","title":"Formatting"},{"location":"client/protocol/#xhtml-im-deprecation","text":"A previous formatting specification defined in XEP-0071 has been deprecated. Many implementations failed to properly sanitize the formatted payload (it's tricky), leading to security issues (particularly in web applications). Implementation of XEP-0071 is not encouraged, but if formatting is a strong requirement along with backwards compatibility (many clients still implement it currently), it remains an option if careful attention is given to sanitizing the XHTML before display. Consider using xhtml-im.js in a web client, or as a reference.","title":"XHTML-IM deprecation"},{"location":"client/protocol/#multi-device","text":"XMPP was ahead of its time in supporting multiple devices connected to a single account - although interestingly even today some popular messaging systems are still limited to a single device, typically mobile, even when many people have a mobile, tablet and laptop or desktop. Historically XMPP aimed to determine which device the user most likely wanted to receive messages on - it did this using a 'priority' mechanism in presence. Over time bandwidth and CPU costs, as well as user expectations, have shifted. Today most people want an \"everything everywhere\" approach to messaging, where all their devices are in sync. Modern XMPP clients should not set a priority in their presence, and they should implement the following XEPs: XEP-0280 - Carbons - for \"live\" synchronisation of conversations between online devices XEP-0313 - MAM - for \"catch-up\" of messages that were exchanged while a device was offline","title":"Multi-device"},{"location":"client/protocol/#known-issues","text":"There are currently some minor open issues regarding these protocols that developers should be aware of.","title":"Known issues"},{"location":"client/protocol/#race-during-login","text":"There is a race condition during login between Carbons and MAM. If you synchronize with the archive first, you may miss some messages sent to other devices before you enable Carbons. If you enable Carbons first, you may receive duplicates from the archive of messages you already received. The current best solution is to enable Carbons, perform the query, and de-duplicate any received messages before presentation to the user. This issue will be solved in the future through XEP-0386 or an alternative atomic \"fetch and subscribe\" command.","title":"Race during login"},{"location":"client/protocol/#ids-of-outgoing-messages","text":"When a client sends a message, it is not currently possible for it to discover the ID that the server assigned to the message in the archive. This means that it is unable to use them as synchronization points and therefore it may receive its last outgoing message(s) when performing an archive sync. Example: Client receives message A, and records the ID so it can use Client sends message B, but the ID is not known to the client Client goes offline Client comes online, and tries to sync with archive. Last known ID was of message A, so it synchronizes from that point Server responds to the sync with message B, and all subsequent messages. Solving this issue may happen through an extension of Carbons (to reflect sent messages back to the sender with the ID added and any other additional info), or through a new MAM subscription protocol.","title":"IDs of outgoing messages"},{"location":"client/protocol/#mobile","text":"There are some special considerations that mobile clients can make to increase battery life and reduce data consumption. XEP-0286 - informational XEP providing advice to mobile developers on efficient data usage XEP-0352 - used to inform the server of whether the client is currently active/focused (which allows the server to prioritize traffic)","title":"Mobile"},{"location":"client/protocol/#reliability","text":"In the real world, it is normal for clients to get briefly disconnected. These extensions deal with ensuring reliable message delivery and reporting. XEP-0184 - end-to-end acknowledgement, i.e. the recipient has successfully received the message XEP-0198 - hop-to-hop acknowledgement, and allows efficient resume of broken connections without data loss","title":"Reliability"},{"location":"client/protocol/#file-transfer","text":"Transferring a file from A to B is surprisingly a non-trivial problem for the internet, it seems. A number of approaches have been tried in XMPP. They are documented here, and fall into two categories: peer-to-peer and server-mediated. It is strongly recommended for clients to implement HTTP upload to provide the best user experience. The other mechanisms are optional (the advantages of implementing each one are documented in the relevant section). There are three file transfer methods that a modern XMPP client may implement: HTTP upload (required) Jingle streams (recommended for large file support) Stream initiation (deprecated, but may be implemented for backwards-compatibility)","title":"File transfer"},{"location":"client/protocol/#http-upload","text":"Required: yes The newest file transfer mechanism available, described in XEP-0363. It is strongly recommended to implement this mechanism to provide the best user experience.","title":"HTTP upload"},{"location":"client/protocol/#benefits","text":"Does not depend on the recipient supporting it (simply falls back to sending a URL) Works with group chats Works when the recipient is offline Allows the recipient to receive on multiple devices","title":"Benefits"},{"location":"client/protocol/#disadvantages","text":"Unsuitable for large files (server determines what the size limit is, and may enforce usage quotas) Does not support streaming (file must be entirely uploaded to the server before recipient can begin to receive it) Requires server support","title":"Disadvantages"},{"location":"client/protocol/#communicating-the-url","text":"After uploading the file successfully, the sender should communicate the URL to the recipient by sending a <message> stanza with the \"Get URL\" provided by the server in the <body> of the message. Additionally the sender should include a jabber:x:oob element in the message stanza with the same URL. Note To enable automatic display of media in the conversation view, Conversations (at least) currently requires that the <body> contain just the URL, and it must be identical to the URL in the jabber:x:oob payload. The <desc> element is not used or supported by Conversations. This behaviour means that it is not possible for any text to directly accompany a media file, and must be sent separately.","title":"Communicating the URL"},{"location":"client/protocol/#jingle","text":"Required: optional - used for large file support Jingle is a generic framework that allows clients to negotiate a direct stream between themselves, which can be used to transfer files (it is also used for voice/video and other p2p applications based on XMPP). It was originally developed at Google and contributed to the XSF where it evolved into today's standard. Because it is a generic framework that supports different underlying transports and different media types, Jingle is split into multiple XEPs. For file transfer the following are relevant: XEP-0166 - the core Jingle framework XEP-0234 - the Jingle file transfer definition XEP-0260 - the most common transport mechanism for files (SOCKS5 bytestreams - may be directly peer-to-peer or server-mediated) XEP-0261 - a fallback transport for tunnelling the data directly over the XMPP stream (inefficient and slow, but always succeeds)","title":"Jingle"},{"location":"client/protocol/#advantages","text":"Supports streaming (recipient receives at the same time as the sender sends) Allows code re-use if the client also implements Jingle for audio/video streams No server-side storage required, and the data will pass directly between clients if firewalls/network conditions allow, which makes it suitable for larger files.","title":"Advantages"},{"location":"client/protocol/#disadvantages_1","text":"Because it is a multi-purpose framework it can be complex. Not all clients support it. In the case of the recipient having multiple devices, only a single one can receive the file. Does not work for sharing a file with multiple people (e.g. in a group chat) Only works if the recipient is online Note Although it is the only recommended negotiation protocol for peer-to-peer streams today, note that Jingle support is not nearly universal even among modern clients.","title":"Disadvantages"},{"location":"client/protocol/#stream-initiation-pre-jingle","text":"Required: no - optionally implement for sending large files to pre-Jingle clients XEP-0096 describes the stream negotiation protocol that was used before Jingle. It is widely supported, and can use the same transports: XEP-0065 XEP-0047 It is not recommended to implement this mechanism in new clients, except for compatibility with older clients is required (and HTTP Upload does not suffice for some reason).","title":"Stream Initiation (pre-Jingle)"},{"location":"client/protocol/#advantages_1","text":"Supports streaming (recipient receives at the same time as the sender sends) Widely supported in older clients","title":"Advantages"},{"location":"client/protocol/#disadvantages_2","text":"Deprecated. Modern clients are switching to Jingle negotiation. In the case of the recipient having multiple devices, only a single one can receive the file. Does not work for sharing a file with multiple people (e.g. in a group chat) Only works if the recipient is online","title":"Disadvantages"},{"location":"client/protocol/#avatars","text":"TODO","title":"Avatars"},{"location":"client/protocol/#group-chat","text":"TODO","title":"Group chat"},{"location":"client/protocol/#contact-management","text":"","title":"Contact management"},{"location":"client/protocol/#blocking","text":"XEP-0191 for blocking communication with a list of other JIDs","title":"Blocking"},{"location":"client/protocol/#encryption","text":"All XMPP streams must be encrypted using TLS as specified in RFC 6920. Clients may additionally support encrypting messages within the XMPP stream. This can prevent untrusted servers from viewing or modifying the contents of exchanged messsages, and is known as 'end-to-end encryption'. The current preferred protocol for this in XMPP is OMEMO, specified in XEP-0384. Client support is indicated at https://omemo.top/ .","title":"Encryption"},{"location":"client/protocol/#notes_1","text":"","title":"Notes"},{"location":"client/protocol/#otr","text":"Prior to OMEMO, many clients implemented the protocol-agnostic encryption protocol \"OTR\". Although it sufficed for simple use cases (sender and recipient have a single device connected, and both support OTR), it has a number of drawbacks when used within XMPP. Traditionally it has not supported multiple devices very well, nor group chats, and it only protects the message body. These issues lead to a poor user experience. Modern XMPP clients that implement OTR must add a XEP-0380 tag to their outgoing messages.","title":"OTR"},{"location":"client/protocol/#mls","text":"The IETF is currently working on standardizing a new protocol for 'Message Layer Security' with support from a number of prominent members of the online communications space. It is hopeful that it may one day allow messaging applications of all protocols to share code and crypto reviewed by experts. However this work is in its early days, and OMEMO is expected to be the recommended approach for some time to come.","title":"MLS"}]}